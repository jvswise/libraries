<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>
	A Arduino Library for sending and receiving DMX
</title><link href="Arduino%20Library%20for%20sending%20and%20receiving%20DMX_files/mathertel.css" rel="stylesheet" type="text/css">
<script src="Arduino%20Library%20for%20sending%20and%20receiving%20DMX_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript">
var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-261452-1']); _gaq.push(['_trackPageview']);
(function () { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();
</script>
</head>
<body>
  
<div class="HEADER">
<div class="PageTitle">
  <div class="MAIN">
    <img src="Arduino%20Library%20for%20sending%20and%20receiving%20DMX_files/logo32.png" class="Logo" alt="create and share" title="create and share">
    <a href="http://www.mathertel.de/Default.aspx" class="Logo" title="Home">mathertel.de</a>
    <div style="text-align: left; margin-top: 12px">
      <div class="VEMenuBar" style="margin-bottom: 6px">
        <a class="VEMenu" href="http://www.mathertel.de/Default.aspx" hover="true">home</a>&nbsp; <a class="VEMenu" href="http://www.mathertel.de/MyProjects.aspx" hover="true">projects</a>&nbsp; <a class="VEMenu" href="http://ajaxaspects.blogspot.com/" hover="true">blog</a>&nbsp; <a class="VEMenu" href="http://www.mathertel.de/impressum.aspx" hover="true">contact</a>&nbsp;
      </div>
    </div>
  </div>
</div>
<span class="SITEMAPPATH"><a href="#Banner1_ctl00_SkipLink"><img alt="Skip Navigation Links" src="Arduino%20Library%20for%20sending%20and%20receiving%20DMX_files/WebResource.gif" style="border-width:0px;" width="0" height="0"></a><span><a title="Public projects of Matthias Hertel." href="http://www.mathertel.de/Default.aspx">www.mathertel.de</a></span><span>&nbsp;--&gt;&nbsp;</span><span><a title="A collection of articles for the Arduino platform with software libraries, schematics and complete projects." href="http://www.mathertel.de/Arduino/default.aspx">Arduino Projects</a></span><span>&nbsp;--&gt;&nbsp;</span><span><a title="This sketch and library shows how to use the hardware serial interface for sending and receiving DMX data packages." href="http://www.mathertel.de/Arduino/DMXSerial.aspx">DMXSerial DMX Library</a></span><a id="Banner1_ctl00_SkipLink"></a></span>
</div>

  <div>
	<div style="float:left;width:100%;">
		<div class="MAIN" style="margin-right:208px;">
			
      
<div class="COLOR_ARDUINO"><h1>A Arduino Library for sending and receiving DMX</h1></div>

      <p>
        This is a library for sending and receiving DMX codes using the Arduino plattform
        or a ATmega (ATmega168, ATmega328 or similar) processor with a clock speed of 16
        MHz.
      </p>
      <p>
        The library avoids timming issues on the low level protocol that typically exist
        when using software implementations by using the
        internal serial communication hardware of the chips. Therefore it is very uncritical
        to add you specific DMX effects on top of this
        communication library.
      </p>
      <p>
        DMX sending and DMX receiving are both supported by this library. You can find a
        brief description of using the details of the
        serial hardware registers in this article.
      </p>
      <h2>Download</h2>
      <p>Download the library files including 3 samples for sending and receiving DMX messages:
      </p>
      <ul>
        <li><a href="http://www.mathertel.de/Arduino/DMXSerialStart.aspx">DMXSerial.zip</a></li>
      </ul>
      <h2>Hardware</h2>
      <p>
        This sketch and library shows how to use the hardware serial interface for sending
        and receiving DMX data packages.
      </p>
      <p>
        To have a minimal DMX compatible hardware you have to add a RS-485 driver chip like
        the MAX481 and attach it to the hardware based
        serial interface of the ATMEGA Microcontroller.&nbsp; A corresponding Arduino compatible
        DMX Shield can be found at <a href="http://www.mathertel.de/Arduino/DMXShield.aspx">DMXShield.aspx</a>.
      </p>
      <h2>DMX and RDM</h2>
      <p>
        DMX521 or DMX in short was defined to control stage lightning effects by using XLR
        style cables. A good starting point for more
        information about the history and evolution of DMX can be found on Wikipedia: <a href="http://en.wikipedia.org/wiki/DMX512">http://en.wikipedia.org/wiki/DMX512</a>
      </p>
      <p>
        Some Arduino related information is also available on the playground of the Arduino
        WebSite: http://www.arduino.cc/playground/Learning/DMX
      </p>
      <p>
        While DMX was designed to have a single sender and multiple receivers. In 2006 a
        bi-directional protocol called RDM was defined
        that enhances DMX that enables a bi-directional communication that I like to support
        as well. See also: http://en.wikipedia.org/wiki/RDM_(lighting)
      </p>
      <p>
        Both, the hardware and software decisions and designs were made to support RDM and
        DMX and die Arduino Shield can be used for all
        of it.
      </p>
      <p>
        With this first version however only DMX Controllers (only sending) and DMX Receivers
        (only listening) are supported mode of operations.
      </p>
      <p>
        Before starting the soldering and programming I did some research on existing DMX
        interface projects and checked for good and bad
        design hints.
      </p>
      <h2>DMX protocol levels</h2>
      <p>
        The logical level of DMX communication is built upon serial sending with 250.000
        baud according the RS-485 definition using no
        parity bits and 2 stop bits.
      </p>
      <p>
        <img src="Arduino%20Library%20for%20sending%20and%20receiving%20DMX_files/DMXSerialLevels.png" alt="DMX serial level schema" style="width: 744px">
      </p>
      <p>
        Luckily the hardware serial ports built in the ATMEGA chips used on the Arduino
        board supports this kind of communication and this
        high baud rate. see also <a href="http://en.wikipedia.org/wiki/RS-485">http://en.wikipedia.org/wiki/RS-485</a>
      </p>
      <p>
        There is nothing really special about the levels of this communication protocol
        except the reset frame which is low for more than
        88 µsec. The 2 stop bits have a minimum time of 8 µsecs but this time can be longer
        up to one second.
      </p>
      <p>
        After a reset frame the payload bytes are transmitted by the DMX host using a start
        byte (value 0) and maximum of 512 channel value
        bytes. It is not recommended to send less than 24 channels.
      </p>
      <p>
        This DMX and RDM specification allows sending and receiving DMX by using the built-in
        hardware. The tricks we need will be explained
        further down.
      </p>
      <h2>Don't use the Arduino Serial implementation</h2>
      <p>
        I have learned to avoid using the standard Serial implementation of the Arduino.
        There is a problem with it when accessing the
        hardware base serial interface because the serial kind of parity and stop bit handling
        is not set at all and the standard values
        are used.
      </p>
      <p>
        Instead of using the built-in Serial object that is implemented in the HardwareSerial
        library this library initializes and controls
        all the Control Registers by itself.
      </p>
      <p>
        There was a first approach published on <a href="http://arduino.cc/playground/Learning/DMXSerial">
          http://arduino.cc/playground/Learning/DMXSerial</a>&nbsp;
        in 2011 that used the build-in Serial implementation but it turned out that when
        using the Interrupt features there is a implementation
        conflict with the interrupt routines needed for DMX and the existing interrupt routines
        of the standard Serial implementation. The
        <a href="http://arduino.cc/playground/DMX/Ardmx">http://arduino.cc/playground/DMX/Ardmx</a>
        site mentions that the core file has
        to be modified - but this is not true in Serial is not used at all.
      </p>
      <p style="color: Red; font-weight: bold">
        So you have to avoid using the Serial object at all and even don't use it for
        debugging
        purpose!
      </p>
      <h2>Using the serial interface through registers</h2>
      <p>
        There are several hardware settings that have to be implemented to enable the built-in
        serial interface. Her I just go through
        the implementation for your orientation how it's done.
      </p>
      <p>
        Sending and receiving DMX The logical level of DMX communication is built upon serial
        sending up to 512 bytes by using 250.000
        baud timings no parity bits and 2 stop bits. Luckily the hardware serial ports built
        in the ATMEGA chips used on the Arduino board
        supports this kind of communication and this high baud rate.
      </p>
      <p>
        Enabling the hardware has to be done by setting the corresponding bits in the USART
        Control and Status Register B. The following
        does enabling sending and the corresponding Data Register Empty Interrupt in the
        case of the DMXController mode:
      </p>
      <pre class="code">// Enable transmitter and interrupt
UCSRnB = (1&lt;&lt;TXENn) | (1&lt;&lt;UDRIEn);</pre>
      <p>
        Enabling the receiver and the corresponding Receive Complete Interrupt in the case
        of the DMXReceiver mode is very similar:
      </p>
      <pre class="code">// Enable receiver and Receive interrupt
UCSRnB = (1&lt;&lt;RXENn) | (1&lt;&lt;RXCEn);</pre>
      <p>
        Setting the baud rate is implemented in the function _DMXSerialBaud because we often
        have to change it when sending DMX packages.
        The source code of this function is very similar to the one used in the standard
        Serial implementation, except that it also sets
        the transmission mode to 2 stop bits, 8 data bits and no parity:
      </p>
      <pre class="code">// initialize the Hardware serial port with the given baud rate
// using 8 data data bits an 2 stop bits.
void _DMXSerialBaud(long baud)
{
  uint16_t baud_setting;

  // calculate baud settings
  baud_setting = (F_CPU / 8 / baud - 1) / 2;

  // assign the baud_setting to the USART Baud Rate Register
  UBRRnH = baud_setting &gt;&gt; 8;
  UBRRnL = baud_setting;

  // 2 stop bits and 8 bit character size, no parity
  UCSRnC = (1&lt;&lt;USBSn) | (3&lt;&lt;USCZn0);
} // _DMXSerialBaud</pre>
      <p>
        Sending a byte using the hardware is done by writing a new value into the USART
        Data Register after checking that there is no current
        transmission.
      </p>
      <pre class="code">void _DMXSerialWrite(uint8_t data)
{
  // Wait for empty transmit buffer
  while ( ! (UCSRnA &amp; (1 &lt;&lt; UDREn)) )
    ;
  // Put data into buffer, sends the data
  UDRn = data;
} // _DMXSerialWrite</pre>
      <h2>Where you can find details about this line of code</h2>
      <div style="border: 1px solid black">
        <p>
          In the official documentation from ATMEL for the ATmega328P microcontroller there
          is a chapter 20 about the internal Universal
          Synchronous and Asynchronous serial Receiver and Transmitter (USART) starting on
          page 178. There are also microcontroller chips
          in the ATmega family that have more than one USART, so the USART also is referenced
          by the USART with number 0 (USART0).
        </p>
        <p>
          In the block diagram you can see that there are some software addressable registers
          (in bold) used to configure these ports. The
          name of the registers are UBRRn, UDRn, UCSRnA, UCSRnB and UCSRnC where n is the
          placeholder for the number of the USART. The concrete
          registers for the USART0 are:
        </p>
        <p>UBRR0H and UBRR0L: Baud Rate Registers</p>
        <p>UDRn: I/O Data Registers</p>
        <p>UCSR0A: Control and Status Register A</p>
        <p>UCSR0B: Control and Status Register B</p>
        <p>UCSR0C: Control and Status Register C</p>
        <p>
          In chapter 20.11 Register Description you can find a short description of each
          register does.
        </p>
        <p>
          The Arduino Serial library takes care of many configuration settings when initialized
          by calling Serial.begin([baud rate]). In
          the folder \hardware\arduino\cores\arduino you can find the file HardwareSerial.cpp
          with the implementation of this library. You
          can search for the begin method and can see that the baud rate is used to calculate
          the values for the registers UBRR0H (_ubrrh)
          and UBRR0L (_ubrrl) and some bits of the register UCSR0B (_ucsrb) are set. There
          is no initialization of the Control and Status
          Register C at all.
        </p>
        <p>
          This line of code sets the serial communication mode to asynchronous mode (UMSEL01
          and UMSEL00 are not set), no parity mode (UPM01
          and UPM02 are not set), 2 stop bits (1&lt;&lt;USBS0) and 8 bit character size (3&lt;&lt;UCSZ00).
        </p>
      </div>
      <h2>The Receive interrupt routine</h2>
      <p>
        Receiving a byte is not implemented using a function, instead a interrupt service
        routine is registered and will be called when
        a data package was detected and received by the hardware. No CPU cycles are needed
        for waiting. The received data is available in
        the USART Data Receive Register UDRn and a potential buffer overflow that will happen
        when receiving the DMX reset signal is available
        in USART Control State Register A UCSRnA. Both values are stored to local variables
        for later use:
      </p>
      <pre class="code">ISR(USART_RX_vect) {
uint8_t USARTstate= UCSRnA; //get state before data!
uint8_t DmxByte = UDRn; //get data
...
}</pre>
      <h2>The Sending interrupt routine</h2>
      <p>
        This interrupt routine is called by the hardware just after a byte was completely
        sent. This routine will then check for the next
        byte that has to be sent out. In DMX Controller mode the routine starts again with
        sending the reset signal when all data of the
        complete package is sent.
      </p>
      <pre class="code">ISR(USART_UDRE_vect) { ... }</pre>
      <h2>Sending the reset</h2>
      <p>
        The standard Arduino chip supports the 250.000 baud transfer rate that is used by
        DMX. The only exception to a plain 250.000 baud
        communication this is the BREAK / reset signal that is a physical low level on the
        wire for more than 88 µsec.
      </p>
      <p>
        This 88 µsec low signal cannot be sent by using the 250.000 baud rate. For sending
        the break a slower baud rate is initialized,
        a 0-byte is sent and the baud rate is reset to the correct 250.000 baud.
      </p>
      <pre class="code">// setup a slower baud rate
_DMXSerialBaud(115200);
// and send a 0 byte
_DMXSerialWrite((uint8_t)0);</pre>
      <p>
        After the BREAK has been sent the following code switches back to 250.000 baud
        for sending the data bytes:
      </p>
      <pre class="code">Serial.begin(250000); 
Serial.write((uint8_t)0);</pre>
      <p>
        The second problem with the format used by DMX is the number of stop bits. Normally
        when using the serial port only one stop bit
        is used. Adding a second stop bit cannot be done through a configuration parameter
        or library call but must be done by adjusting
        the hardware setting for the serial port 0:
      </p>
      <pre class="code">UCSR0C = (1&lt;&lt;USBS0)|(3&lt;&lt;UCSZ00);</pre>
      <p>
        You can find this code in the interrupt service routine to start a complete DMX
        package and continuously sending out the DMX values
        in the DMXController mode.
      </p>
      <p>
        A design for a DMX Shield that works with this library can be found in the article:
        <a href="http://www.mathertel.de/Arduino/DMXShield.aspx">DMX Shield</a>.
      </p>
      <h2>How to detect, that a device is disconnected?</h2>
      <p>
        It is not possible to detect that no cable is actually attached to a device without
        adding more hardware. So there is a more soft
        (software based) solution for that.
      </p>
      <p>
        When a DMX start packet is received the library remembers the current time to a
        static variable. By using this value the method
        "DMXSerial.noDataSince()" the returns the number of milliseconds since the last
        packet was received.
      </p>
      <p>The time is calculated by using the millis() function.</p>
      <p>
        In the main loop or anywhere else you can check if the DMX signal was received during
        the last time and react if it is too long
        ago.
      </p>
      <p>
        In the DmxSerialRecv.pde sample there is a call to the function for showing a fallback
        color (red in my case).
      </p>
      <h2>Links</h2>
      <p>
        DMX on the Arduino website. A good starting point for research:<br>
        <a href="http://www.arduino.cc/playground/Learning/DMX">http://www.arduino.cc/playground/Learning/DMX</a>
      </p>
      <p>
        About the HSL HSV and RGB Color models:<br>
        <a href="http://en.wikipedia.org/wiki/HSL_and_HSV">http://en.wikipedia.org/wiki/HSL_and_HSV</a>
      </p>
      <p>
        The documentation for the ATmega328P microcontroller can be found at:<br>
        <a href="http://www.atmel.com/dyn/resources/prod_documents/doc8271.pdf">http://www.atmel.com/dyn/resources/prod_documents/doc8271.pdf</a>
      </p>
      <p>
        RS-485 description<br>
        <a href="http://en.wikipedia.org/wiki/RS-485">http://en.wikipedia.org/wiki/RS-485</a>
      </p>
      <p>
        DMX description<br>
        <a href="http://en.wikipedia.org/wiki/DMX512">http://en.wikipedia.org/wiki/DMX512</a>
      </p>
      <p>
        MAX481 and MAX485 from MAXIM: <a href="http://www.maxim-ic.com/datasheet/index.mvp/id/1111">
          http://www.maxim-ic.com/datasheet/index.mvp/id/1111</a>
      </p>
      <h2>History</h2>
      <ul>
        <li>24.08.2011 First published version.</li>
        <li>04.12.2011 Updated for compatibility with the Arduino 1.0 environment.</li>
        <li>10.05.2012 Added the method DMXSerial.noDataSince()</li>
        <li>04.06.2012 Now initializing the register UCSRnA to 0 correctly to avoid problems
          with Arduino Unos double speed baud settings.</li>
        <li>11.08.2012 Update to adjust some timing conditions and optimizations. Thanks a
          lot to Jonathan L.</li>
        <li>19.05.2013 Update to support multiple boards and configurations: MEGA 2560, Leonardo
          etc.</li>
        <li>19.05.2013 Update to support ATmega8 chips (still beta).</li>
        <li>01.07.2013 Added another example sketch.</li>
        <li>26.08.2013 Some minor fixes.</li>
      </ul>
    
		</div>
	</div><div class="SIDEBAR" style="float:left;width:204px;margin-left:-204px;">
		
      
<div align="center">
<div style="padding:4px 0px 4px 0px">
<form action="http://www.google.com/cse" id="cse-search-box">
  <div>
    <input name="cx" value="partner-pub-7960252409517973:bknuxt-3rgj" type="hidden">
    <input name="ie" value="UTF-8" type="hidden">
    <input name="q" size="16" style="height: 16px; background: url(&quot;http://www.google.com/cse/intl/en/images/google_custom_search_watermark.gif&quot;) no-repeat scroll left center rgb(255, 255, 255);" type="text"><input name="sa" value="&gt;" style="height: 22px;" type="submit">
  </div>
<input value="www.mathertel.de/Arduino/DMXSerial.aspx" name="siteurl" type="hidden"><input value="playground.arduino.cc/Learning/DMXSerial" name="ref" type="hidden"><input name="ss" type="hidden"></form>
<script type="text/javascript" src="Arduino%20Library%20for%20sending%20and%20receiving%20DMX_files/brand"></script> 
</div>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-7960252409517973";
google_ad_slot = "5256574873";
google_ad_width = 120;
google_ad_height = 600;
//--></script>
<script type="text/javascript" src="Arduino%20Library%20for%20sending%20and%20receiving%20DMX_files/show_ads.js"></script><ins style="display:inline-table;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:120px;background-color:transparent"><ins id="aswift_0_anchor" style="display:block;border:none;height:600px;margin:0;padding:0;position:relative;visibility:visible;width:120px;background-color:transparent"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;" scrolling="no" width="120" frameborder="0" height="600"></iframe></ins></ins>
</div>


    
	</div>
</div>
  
<hr><p>This page is part of the <a href="http://www.mathertel.de/">http://www.mathertel.de/</a> web site.</p>


</body></html>